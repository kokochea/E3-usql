Documentación del Código
Este código implementa un parser básico para un lenguaje SQL personalizado llamado "USQL" utilizando las bibliotecas ply y numpy. Las principales funciones del código incluyen el análisis léxico y sintáctico de comandos específicos en USQL, que se traducen luego a sentencias SQL estándar.

Componentes Principales
Tokens Reservados y Simples:

Los tokens reservados como TRAEME, TODO, MEZCLANDO, etc., se definen en el diccionario reserved.
Los tokens simples (ID, COMPARADORES, NUMBER, STRING, etc.) utilizan expresiones regulares para identificar nombres de tablas, operadores de comparación, números, comillas, etc.
Tokens con Espacios:

Algunos tokens como METE EN, LOS VALORES y ORDENA POR requieren espacios en su definición, por lo cual se definen con funciones t_nombre_del_token.
Funciones de Análisis Léxico (t_<TOKEN>):

Cada función t_<TOKEN> devuelve el token correspondiente cuando es identificado en el análisis léxico.
Reglas Sintácticas:

Se definen varias funciones p_<NOMBRE_REGLA> para construir las diferentes estructuras de USQL, traduciendo consultas en comandos SQL estándar.
Ejemplos de consultas incluyen SELECT, INSERT, UPDATE, DELETE, ALTER TABLE, entre otras.
Cada función construye y retorna un string SQL utilizando las reglas de gramática definidas, como p_query_select, p_query_insert, p_query_update, etc.
Funciones Auxiliares y Reglas Opcionales:

Opcionales (opcionales): define cláusulas adicionales como WHERE, GROUP BY, JOIN, etc.
Alter Opcionales (alter_opcionales): reglas para operaciones ALTER TABLE como ADD COLUMN, DROP COLUMN, RENAME, etc.
Where, Join, Group, y Having: especifican condiciones para filtros de consulta.
Condiciones (p_condicion): identifica expresiones de comparación (entre y y) para valores en USQL.
Errores:

Los errores en los tokens se manejan en t_error, mientras que los errores sintácticos se manejan en p_error, ambos mostrando un mensaje descriptivo cuando se encuentran errores.
Ejecutar el Lexer y Parser:

Al final, una función run() permite ejecutar el parser en modo interactivo para recibir entradas y analizarlas. El programa también puede iniciar en un modo de entrada continua (while True), evaluando cada línea introducida y devolviendo la traducción a SQL correspondiente.